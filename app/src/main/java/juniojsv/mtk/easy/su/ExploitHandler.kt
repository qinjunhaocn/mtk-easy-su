package juniojsv.mtk.easy.su

import android.content.Context
import android.content.SharedPreferences
import java.io.File
import java.io.FileOutputStream

data class ExploitResult(val isSuccessful: Boolean, val log: String)

class ExploitHandler(
    private val context: Context,
    onPostExecute: (result: ExploitResult) -> Unit
) : CoroutineTask<ExploitResult>(onPostExecute) {

    private val preferences: SharedPreferences =
        context.getSharedPreferences(BuildConfig.APPLICATION_ID, Context.MODE_PRIVATE)

    override fun onPreExecute() {
        // 设置全局标志，表示Exploit正在运行
        isExploitRunning = true
        context.getString(R.string.executing_script).toast(context, true)
    }

    override fun doInBackground(): ExploitResult {
        val log = StringBuilder("Mtk-easy-su ${BuildConfig.VERSION_NAME}\n")
        val files = arrayListOf<File>()
        with(context) {
            try {
                val dstBoot = File(filesDir.absoluteFile, "magisk-boot.sh")
                assets.open("magisk-boot.sh").use { input ->
                    FileOutputStream(dstBoot).use { output ->
                        input.copyTo(output, 512)
                    }
                }
                Runtime.getRuntime().exec("chmod 510 ${dstBoot.absolutePath}").waitFor()
                files.add(dstBoot)
                log.append("extracted ${dstBoot.toRelativeString(context.filesDir)}\n")

                val is64 = try {
                    android.os.Build.SUPPORTED_64_BIT_ABIS?.isNotEmpty() == true
                } catch (e: Throwable) {
                    System.getProperty("os.arch")?.contains("64") == true
                }

                val dstMagiskinit = File(filesDir.absoluteFile, "magiskinit")
                val dstMtkSu = File(filesDir.absoluteFile, "mtk-su")
                val assetList = assets.list("")?.toList() ?: emptyList()
                val magiskinitAsset = if (assetList.contains("magiskinit")) "magiskinit" else if (is64) "magiskinit64" else "magiskinit32"
                val mtkSuAsset = if (assetList.contains("mtk-su")) "mtk-su" else if (is64) "mtk-su64" else "mtk-su32"

                assets.open(magiskinitAsset).use { input ->
                    FileOutputStream(dstMagiskinit).use { output ->
                        input.copyTo(output, 512)
                    }
                }
                Runtime.getRuntime().exec("chmod 510 ${dstMagiskinit.absolutePath}").waitFor()
                files.add(dstMagiskinit)
                log.append("extracted ${dstMagiskinit.toRelativeString(context.filesDir)}\n")

                assets.open(mtkSuAsset).use { input ->
                    FileOutputStream(dstMtkSu).use { output ->
                        input.copyTo(output, 512)
                    }
                }
                Runtime.getRuntime().exec("chmod 510 ${dstMtkSu.absolutePath}").waitFor()
                files.add(dstMtkSu)
                log.append("extracted ${dstMtkSu.toRelativeString(context.filesDir)}\n")

                val packageManager = context.packageManager
                val isMagiskManagerInstalled = try {
                    packageManager.getPackageInfo("com.topjohnwu.magisk", 0)
                    true
                } catch (e: Exception) {
                    false
                }
                val assetsList = assets.list("")?.toList() ?: emptyList()
                if (!isMagiskManagerInstalled && assetsList.contains("magisk-manager.apk")) {
                    val targetDir = context.getExternalFilesDir(null) ?: context.filesDir
                    val apkFile = File(targetDir, "magisk-manager.apk")
                    context.assets.open("magisk-manager.apk").use { input ->
                        FileOutputStream(apkFile).use { output ->
                            input.copyTo(output)
                        }
                    }
                    log.append("APK extracted to ${apkFile.absolutePath}\n")
                } else if (isMagiskManagerInstalled) {
                    log.append("Magisk Manager already installed, skipping APK extraction.\n")
                }
            } catch (e: Exception) {
                log.append(e.message)
            }
        }

        arrayOf(
            "getprop ro.vendor.product.model",
            "getprop ro.build.version.release",
            "date",
            "ls -R -1 -h -g ${context.filesDir.absolutePath}",
            "cat /proc/cpuinfo", "cat /proc/meminfo",
            "free", "cat /proc/version",
            "sh ${context.filesDir.absolutePath}/magisk-boot.sh ${context.filesDir.absolutePath}"
        ).forEach { command ->
            try {
                log.append(Runtime.getRuntime().exec(command).getOutput())
            } catch (e: Exception) {
                log.append(e.message)
            }
        }

        val isSuccessful = File("/sbin/su").exists()

        try {
            files.forEach { file ->
                file.deleteRecursively().let { success ->
                    if (success)
                        log.append("deleted ${file.toRelativeString(context.filesDir)}\n")
                }
            }
        } catch (e: Exception) {
            log.append(e.message)
        }

        return ExploitResult(isSuccessful, log.toString())
    }

}